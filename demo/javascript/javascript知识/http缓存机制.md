#### HTTP缓存

> - [x] 减少冗余的数据传输,节省宽带流量
> - [x] 减少了服务器的负担,大大提高网站性能
> - [x] 加快客户端加载页面的速度,这也是http缓存属于客户端缓存的原因

1. 强制缓存

   > 当缓存数据库中命中已有所请求的数据时,客户端直接从缓存数据库中获取数据,当没有所请求数据时,客户端才会从 服务端获取数据

2. 协商缓存

   > 对比缓存,客户端首先会从缓存数据库中获取一个缓存数据的标识,得到标识后,请求服务端验证是否失效,如果没有失效则返回304,此时客户端直接从缓存中获取所请求的数据,如果标示失效,服务端会返回更新后的数据

###### 注意

两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商

#### 缓存的方案

> 浏览器与服务器进行交互是发送请求和响应数据:http报文
>
> 首部:header
>
> 主体部分:body
>
> 与缓存相关的内容在header中

#### header中与缓存相关的内容

1. 强制缓存

   对于强制缓存,**服务器响应**的header中会用两个字段来表明-- Expires和Cache-control

   ###### Expires

   > Expires的值为服务端返回的数据到期时间,当在此请求时的请求时间小于返回的此时间,则直接使用缓存数据,但由于服务端时间和客户端时间可能存在误差,这也将导致缓存命中的误差,另一方面,它是`HTTP1.0`的产物,因此现在大多使用`Cache-Contol`替代

   ###### Cache-Control

   > 有很多属性,不同属性代表的意义也不同
   >
   > private:客户端可以缓存
   >
   > public:客户端和代理服务器都可以缓存
   >
   > max-age=他:缓存内容在t秒后失效
   >
   > no-cache:需要协商缓存来验证缓存数据
   >
   > no-store:所有内容都不会缓存

2. 协商缓存

   协商缓存需要进行对比判断是否可以使用缓存

   浏览器进行第一次请求数据时,服务其会将缓存标识和数据一起发送给可获段,客户端将他们备份到缓存,再次请求时,客户端将标识发送给服务器,服务器根据此标识判断缓存是否失效,若未失效,返回304状态码,浏览器此时根据此状态码可以直接使用缓存数据

   ###### Last-Modified

   > 服务器在响应请求时,告诉浏览器资源的最后修改时间

   ###### if-Modified-Since

   > 浏览器再次请求服务器时,请求头会包含此字段,后面跟着在缓存中获得的最后修改时间,服务端获得此请求头发现有if-Modified-Since,则与被请求资源的最后修改时间进行对比,如果一致返回304和响应报文头

   ###### if-Unmodified-Since

   > 从某个时间算起,是否未修改
   >
   > 1. 如果没有被修改,继续传输文件:200 OK
   > 2. 如果文件被修改:服务返回 412 Precondition(预处理错误)

   ###### Etag

   Last-Modified 存在一个问题,修改时间虽然改变了,但是其内容可能没有发生任何变化

   > `Etag`:服务器响应请求时,通过此字段告诉浏览器当前资源在服务器生成的唯一标识(生成规则由服务器决定)
   >
   > If-None-Match:再次请求服务其是浏览器的请求头会包含此字段,后面的值为缓存中获取的标识,,服务器接收到此报文后,发现这个字段则与被请求的资源的唯一标识进行对比,一致则返回304,不一致则将整个资源内容返回
   >
   > - 实际应用中`Etag`是通过算法算出的,占用服务器计算的资源,所以很少使用

#### 不同刷新的请求过程

1.浏览器地址栏中写入URL,回车,浏览器发现缓存中有这个文件了,就不用继续请求了,而是直接去拿

2.`F5`,浏览器向服务端发送If-Modify-Since,看看资源是否过期

3.`ctrl+F5`,将缓存中的数据删掉,到服务请求整个资源