## 基本类型和引用类型的值

> 将一个值赋值给变量时,解析器必须确定这个值是基本类型还是引用类型,以确定如何存储变量
>
> 值的访问:按值访问,按引用访问

#### 动态属性

对于引用类型的值可以为其添加属性和方法

#### 复制变量的值

- [ ] 基本类型的值:复制变量对象的值到新变量分配的空间上,两个变量之间完全独立
- [ ] 引用类型的值:与基本类型的值的复制相同,不过这个值是一个指向堆中一个对象的指针

#### 传递参数

> 所有函数的参数都是按值传递的
>
> 基本类型的值的传递如基本类型变量的复制
>
> 引用类型值的传递如图引用类型变量的复制
>
> 将参数当做是局部变量即可

#### 检测类型

对于基本类型来说,`typeof`操作符

检测对象:`instanceof` 操作符,  `variable instanceof constructor`

所有引用类型的值都是Object的实例,`instanceof`检测基本类型的值总是返回`false`

## 执行环境及作用域

> 1. 执行环境定义了变量或函数有权访问的其他数据,决定了他们各自的行为
> 2. 每个执行环境都有与之关联的变量对象,环境中所定义的函数和变量都保存在这个变量对象中
> 3. 变量对象是无法访问的
>
> 全局执行环境是最外围的执行环境,根据`ECMAScript`实现所在的宿主机不同,执行环境的对象也不一样
>
> - web浏览器中,全局执行环境为window
>
> ​      某个执行环境中所有代码执行完毕后,该环境被销毁,其中的变量函数也被销毁
>
> ​     全局执行环境知道应用程序退出才被销毁
>
> - 每个函数都有自己的执行环境
>
>   执行流进入函数,函数环境会被推入一个环境栈中,当函数执行完时,从栈中弹出,将控制器返回给之前的执行环境
>
> - 变量对象上的作用域链
>
>   1 保证对执行环境有权访问的所有变量和函数的有序访问
>
>   2 作用域链的前端始终都是当前执行代码所在环境的变量对象
>
>   3下一个变量对象依次像全局执行环境变量对象递推

#### 延长作用域链

> 在作用域前端临时增加一个变量对象
>
> try-catch的catch块
>
> with语句

#### 没有块级作用域

1. var 变量提升,在for语句中声明的对象,执行完仍然可以访问

   var声明的对象会被自动添加到最近的环境中

   函数中,不经声明的变量,将被添加到全局环境中

2. 查询标识符,从作用链前端开始查询直到找到或者最后一个变量对象

## 垃圾收集

> - 自动垃圾收集机制:执行环境会负责管理代码执行过程中使用的内存
>
> - 原则:找到不再继续使用的变量,然后释放内存
>
> - 垃圾收集器会按照固定的时间间隔(或代码中预定的收集时间),周期性地执行这一操作
>
> - 垃圾收集器必须跟踪哪个变量有用,哪个变量没用
>
> **标识无用变量的策略**
>
> 1. 标记清除
>
>    策略: 
>
>    - 在运行时给内存中的所有变量都加上标记
>    - 然后去掉环境中的变量及被环境中变量引用的变量的标记
>    - 最后将还有标记的变量所占用的内存删除
>
>    实现:
>
>    ​	大多数浏览器都采用这一策略,IE,Firefox,Chrome和Safari,Opera等
>
> 2. 引用计数
>
>    不太常用
>
>    策略:
>
>    - 跟踪记录每个值被引用的次数
>    - 如果是引用类型值,又复制给其他则引用次数加1
>    - 包含这个值引用的变量又取其他值引用次数减1
>    - 当这个值的引用此时为0时,说明就可以释放了
>
>    问题:循环引用
>
>    设置null断开连接
>
> 3. 性能问题
>
>    - 垃圾收集器频繁的执行
>
> 4. 管理内存
>
>    > - 内存限制:
>    >
>    >   分配给Web浏览器的可用内存通常要比分配给桌面英语程序的少;
>    >
>    >    防止网页消耗全部系统内存而导致系统崩溃
>    >
>    > - 解除引用
>    >
>    >   一旦数据不再有用最好的方式是设置为null来释放引用
>    >
>    >   适合全局变量和全局对象的属性
>    >
>    >   局部变量会在离开执行环境时自动解除引用
>    >
>    >   解除引用的作用是让值脱离指向环境,以便垃圾收集器**下次**运行时将其回收

